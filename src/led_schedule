#include <DS3132_p>
#include <Bluetooth_module>

/*
void SM_led1 () {

state_prev_led1 = state_led1;

//state machine section

switch (state_led1)
{
  case 0: //RESET
  state_led1 = 1;
  break;

 case 1: //Check TimePicker & Initialize
 if ((timepicker_hours == hours) && (timepicker_minutes == minutes)){state_led1 = 2;}
break;

//case 44: //Check TimePicker & Initialize
// if (timepicker_minutes == minutes){state_led1 = 2;}
//break;

  case 2: //Set PWM
  analogWrite(led3, ledstrip_pwm);
  hours_counter = ledstrip_duration;
  state_led1 = 3;
  break;

  case 3:
  if (hours != old_hours_value) {
        old_hours_value = hours;
        hours_counter--;

if (hours_counter < 0)
{
  state_led1 = 4;
}
  }
    break;

    case 4:
  analogWrite(led3, ledstrip_pwm2);
  hours_counter = ledstrip_duration2;
  state_led1 = 5;
    break;

    case 5:
    
  if (hours != old_hours_value) {
        old_hours_value = hours;
        hours_counter--;


if (hours_counter <= 0)
{
  state_led1 = 6;
}
  }
    break;

  case 6:
  analogWrite(led3, ledstrip_pwm3);
  hours_counter = ledstrip_duration3 ;
  state_led1 = 7;
    break;

    case 7:
    
  if (hours != old_hours_value) {
        old_hours_value = hours;
        hours_counter--;

if (hours_counter <= 0)
{
  state_led1 = 8;
}
  }
    break;
    
    case 8:
    analogWrite(led3, 0);
  
    timepicker_hours = -1; // To may remove this
    timepicker_minutes = -1; // and this
    state_led1 = 0;
    break;

}

}
*/

void print_state_readEEPROM (){
if(state_readEEPROM != state_prev_readEEPROM)
{
Serial.print("                     STATE READ EEPROM = ") ; 
Serial.println(state_readEEPROM);
}
}

void print_state_writeEEPROM (){
if(state_writeEEPROM != state_prev_writeEEPROM)
{
Serial.print("                     STATE WRITE EEPROM = ") ; 
Serial.println(state_writeEEPROM);
}
}


/*
void print_state_led1 (){
if(state_led1 != state_prev_led1)
{
Serial.print("                     STATE LED 1 = ") ; 
Serial.println(state_led1);
}
}

void print_state_pump (){
if(state_pump != state_prev_pump)
{
Serial.print("\n \n \t STATE PUMP = ") ; 
Serial.println(state_pump);
}
}
*/
 int pump_state = LOW;

void test12 (){

 if(millis() >= time_now2 + period2)
{
  Serial.println("\n \t");
 // Serial.print(tank_level);
  Serial.println("\n \t");
 //  Serial.print(distance);
  Serial.print(pump_state);
 shtc3();
 tsl2561();
 pressure();

 send_BT(temp_SHTC3_ID, t_scaled);    // function to write id and value to the bluetooth interface (and split value in MSB and LSB       
 send_BT(humidity_SHTC3_ID, h_scaled);    // function to write id and value to the bluetooth interface (and split value in MSB and LSB
 send_BT(TSL2561_LUX_ID,TSL2561.readVisibleLux());
 send_BT(TSL2561_FSpec_ID,TSL2561.readFSpecLuminosity());
 send_BT(TSL2561_IR_ID,TSL2561.readIRLuminosity());
 send_BT(pressure_ID, pressure_bar);  
 //send_BT(ultrasonic_ID,tank_level);
 
 time_now2 += period2;
}
 
 



}







const int pump = 4; // define pump pin
//int state_pump = 0;
//int state_prev_pump = 0;
//int val_pump = 0;
//unsigned long t_pump = 0; //Previous Millis()
//unsigned long t_0_pump = 0; //Current Millis()
unsigned long prev_millis = 0;

 

void pumpTimings()
{

  pump_onDuration_UL = pump_onDuration * 1000;
  pump_offDuration_UL = pump_offDuration * 1000;
 // check to see if it's time to change the state of the pump
 

  if (Auto_EN_DIS != 0)
{

 Manual_ON_OFF = 0;
 unsigned long currentMillis = millis();
 // HIGH = OFF . LOW = ON // LOW LVL RELAY MODULE
  if((pump_state == HIGH) && (currentMillis - prev_millis >= pump_onDuration_UL))
  {
    pump_state = LOW;  // Turn it off
    prev_millis = currentMillis;  // Remember the time
    digitalWrite(pump, !pump_state);  // Update the actual pump
  }
  else if ((pump_state == LOW) && (currentMillis - prev_millis >= pump_offDuration_UL))
  {
    pump_state = HIGH;  // turn it on
    prev_millis = currentMillis;   // Remember the time
    digitalWrite(pump, !pump_state);	  // Update the actual pump
  }
 }
 
 if (Auto_EN_DIS !=1)
{

digitalWrite (pump,!Manual_ON_OFF);

}
}

/*
void SM_pump() {
  //Almost every state needs these lines, so I'll put it outside the State Machine
  
  state_prev_pump = state_pump;
  pump_onDuration_UL = pump_onDuration * 1000;
  pump_offDuration_UL = pump_offDuration * 60000;
  int pump_state = LOW;
  //State Machine Section
  switch (state_pump) {
    case 0: //RESET!
    //
  digitalWrite(pump, LOW);
  state_pump = 1;
    break;
    
    case 1: //WAIT
    if (Auto_EN_DIS == 1) { state_pump = 2;}
      //Do nothing.  Only the top level(main) loop can force us out of this state into state 2 "TURN ON"
    break;
  
 case 2: //TURN ON
      //Start pump, record time then proceed to ON, 
      digitalWrite(pump,HIGH);
      t_0_pump = millis();
      state_pump = 3;
    break;
       
 case 3: //ON
      //Wait for time to elapse, then proceed to TURN OFF
      t_pump = millis();
      if (t_pump - t_0_pump > pump_onDuration_UL) {state_pump = 4;}
    break;  
    
 case 4: //TURN OFF
      //, turn off relay, proceed to OFF
      
      t_0_pump = millis();
      digitalWrite(pump,LOW);
      state_pump = 5;
    break; 
    
 case 5: //OFF
      t_pump = millis();
      if (t_pump - t_0_pump > pump_offDuration_UL) {state_pump = 6;}
    
      //if (beep_count_led1 >= beep_number_led1) {state_led1 = 0;}
    break;
 case 6: //RECORD CURRENT TIME
      t_0_pump = millis();
      state_pump = 7;
	 break; 
 case 7: //WAIT THEN FINISH
      t_pump = millis();
      if (t_pump - t_0_pump > 200) {state_pump = 0;}
	 break;   
  	}
  }
  */
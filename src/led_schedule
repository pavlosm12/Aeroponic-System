#include <DS3132_p>
#include <Bluetooth_module>


int state_prev_light = 0;
int state_light = 0;
int light_Schedule_dur;
void SM_light () {

state_prev_light = state_light;

//state machine section
switch (state_light)
{
  case 0: //RESET
  state_light = 1;
  break;

 case 1: //Check TimePicker & Initialize
 if ((timepicker_hours == hours) && (timepicker_minutes == minutes)){state_light = 2;}
break;


  case 2: //Set PWM
  
  light_Schedule_dur = light_onDuration * 60; // ta 60 na ginoun 3600 meta th dokimh
  ticks = 0;
  state_light = 3;
  break;

  case 3:
   analogWrite(light, light_Intensity);

if (ticks >= light_Schedule_dur)
{
  state_light = 4;
}
    break;
    
    case 4:
    analogWrite(light, LOW);
    ticks = 0;
    state_light = 0;
    break;

  }
}




void print_state_readEEPROM (){
if(state_readEEPROM != state_prev_readEEPROM)
{
Serial.print("                     STATE READ EEPROM = ") ; 
Serial.println(state_readEEPROM);
}
}

void print_state_writeEEPROM (){
if(state_writeEEPROM != state_prev_writeEEPROM)
{
Serial.print("                     STATE WRITE EEPROM = ") ; 
Serial.println(state_writeEEPROM);
}
}


/*
void print_state_led1 (){
if(state_led1 != state_prev_led1)
{
Serial.print("                     STATE LED 1 = ") ; 
Serial.println(state_led1);
}
}

void print_state_pump (){
if(state_pump != state_prev_pump)
{
Serial.print("\n \n \t STATE PUMP = ") ; 
Serial.println(state_pump);
}
}
*/
 int pump_state = HIGH;

void pressure() //loop routine runs over and over again forever
{

  if (pump_state == LOW)
  {
  pressureValue = analogRead(pressureInput); //reads value from input pin and assigns to variable
  }
  else if ( pressureValue <= 0)
  {
    pressureValue = 0;
  }
  pressureValue = ((pressureValue-pressureZero)*pressuretransducermaxPSI)/(pressureMax-pressureZero); //conversion equation to convert analog reading to psi
  pressure_bar = pressureValue * 0.068948;
  //Serial.print(pressure_bar, 1); //prints value from previous line to serial
 // Serial.println("bar"); //prints label to serial

}

void test12 (){

 if(millis() >= time_now2 + period2)
{
  Serial.println("\n \t");
 // Serial.print(tank_level);
  Serial.println("\n \t");
 //  Serial.print(distance);
  Serial.print(!pump_state);
    Serial.println("\n \t");
 Serial.print(pressureValue);
  Serial.println("\n \t");

Serial.print("Ping: ");
   Serial.print(distance); // Ping returned, uS result in ping_result, convert to cm with US_ROUNDTRIP_CM.
    Serial.println("cm");
 shtc3();
 //tsl2561();
 TSL2561B();

send_BT(temp_SHTC3_ID, t_scaled);    // function to write id and value to the bluetooth interface (and split value in MSB and LSB        
send_BT(humidity_SHTC3_ID, h_scaled);    // function to write id and value to the bluetooth interface (and split value in MSB and LSB
send_BT(pressure_ID, pressure_bar); 
send_BT(hours_ID,hours);
send_BT(minutes_ID,minutes);
send_BT(ultrasonic_ID, waterTank_level);
 //send_BT(TSL2561_LUX_ID,TSL2561.readVisibleLux());
 //send_BT(TSL2561_FSpec_ID,TSL2561.readFSpecLuminosity());
 //send_BT(TSL2561_IR_ID,TSL2561.readIRLuminosity());
 
 if ((lux > 16000) && (lux <= 65535))
 {
  lux_underscaled = round(lux / 100);
  send_BT(TSL2561_LUX_ID_underscaled, lux_underscaled);
 }
 else 
 {
  send_BT(TSL2561_LUX_ID, lux);
 }

 if ((full > 16000) && (full <= 65535))
 {
  full_underscaled = round(full / 100);
  send_BT(TSL2561_FSpec_ID_underscaled, full_underscaled);
 }
 else 
 {
  send_BT(TSL2561_FSpec_ID, full);
 }

 if ((ir > 16000) && (ir <= 65535))
 {
  ir_underscaled = round(ir / 100);
  send_BT(TSL2561_IR_ID_underscaled, ir_underscaled);
 }
 else 
 {
  send_BT(TSL2561_IR_ID, ir);
 }
 
// send_BT(TSL2561_LUX_ID, lux);
// send_BT(TSL2561_FSpec_ID, full);
 //send_BT(TSL2561_IR_ID, ir);
 
 
 
 time_now2 += period2;
  }
}







const int pump = 4; // define pump pin
unsigned long prev_millis = 0;


void pumpTimings()
{

  pump_onDuration_UL = pump_onDuration * 1000;
  pump_offDuration_UL = pump_offDuration * 1000;
 // check to see if it's time to change the state of the pump
 

  if (Auto_EN_DIS != 0)
{

 Manual_ON_OFF = 0;
 unsigned long currentMillis = millis();
 // HIGH = OFF . LOW = ON // LOW LVL RELAY MODULE
  if((pump_state == HIGH) && (currentMillis - prev_millis >= pump_onDuration_UL))
  {
    pump_state = LOW;  // Turn it off
    prev_millis = currentMillis;  // Remember the time
    digitalWrite(pump, !pump_state);  // Update the actual pump
  }
  else if ((pump_state == LOW) && (currentMillis - prev_millis >= pump_offDuration_UL))
  {
    pump_state = HIGH;  // turn it on
    prev_millis = currentMillis;   // Remember the time
    digitalWrite(pump, !pump_state);	  // Update the actual pump
  }
 }
 
 if (Auto_EN_DIS !=1)
{
pump_state = !Manual_ON_OFF;
digitalWrite (pump,pump_state);

}
}







/*
/////////// TO TEST THE$ CODE BELOW!! /////////////////////

int buzzer_state = LOW;
unsigned long prev_millis2 = 0;
unsigned long buzzer_onTime = 0;
unsigned long buzzer_offTime = 0;

void buzzerTimings ()
{


if (set_alarm !=0)
{

unsigned long currentMillis2 = millis();
 // HIGH = OFF . LOW = ON // LOW LVL RELAY MODULE
  if((buzzer_state == HIGH) && (currentMillis2 - prev_millis2 >= buzzer_onTime))
  {
    buzzer_state = LOW;  // Turn it off
    prev_millis = currentMillis2;  // Remember the time
    digitalWrite(buzzer, buzzer_state);  // Update the actual pump
  }
  else if ((buzzer_state == LOW) && (currentMillis2 - prev_millis2 >= buzzer_offTime))
  {
    buzzer_state = HIGH;  // turn it on
    prev_millis2 = currentMillis2;   // Remember the time
    digitalWrite(buzzer, buzzer_state);	  // Update the actual pump
  }
}
}
//// TO TEST THE CODE ABOVE ///////
*/


////TO TEST THE CODE BELOW///

/*
if ((pressure < Lower_pressure_TH) || (pressure > Upper_pressure_TH)
{
  set_alarm = 1;
}

else if (WaterTank_Alarm_Level < "WATER TANK LEVEL VALUE!!")

{
  set_alarm = 1;
}

else 
{
  set_alarm = 0;
  buzzer_state = LOW;
}


*/

////// TO TEST THE CODE ABOVE///
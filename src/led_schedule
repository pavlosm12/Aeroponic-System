#include <DS3132_p>
#include <Bluetooth_module>

/*
void SM_led1 () {

state_prev_led1 = state_led1;

//state machine section

switch (state_led1)
{
  case 0: //RESET
  state_led1 = 1;
  break;

 case 1: //Check TimePicker & Initialize
 if ((timepicker_hours == hours) && (timepicker_minutes == minutes)){state_led1 = 2;}
break;

//case 44: //Check TimePicker & Initialize
// if (timepicker_minutes == minutes){state_led1 = 2;}
//break;

  case 2: //Set PWM
  analogWrite(led3, ledstrip_pwm);
  hours_counter = ledstrip_duration;
  state_led1 = 3;
  break;

  case 3:
  if (hours != old_hours_value) {
        old_hours_value = hours;
        hours_counter--;

if (hours_counter < 0)
{
  state_led1 = 4;
}
  }
    break;

    case 4:
  analogWrite(led3, ledstrip_pwm2);
  hours_counter = ledstrip_duration2;
  state_led1 = 5;
    break;

    case 5:
    
  if (hours != old_hours_value) {
        old_hours_value = hours;
        hours_counter--;


if (hours_counter <= 0)
{
  state_led1 = 6;
}
  }
    break;

  case 6:
  analogWrite(led3, ledstrip_pwm3);
  hours_counter = ledstrip_duration3 ;
  state_led1 = 7;
    break;

    case 7:
    
  if (hours != old_hours_value) {
        old_hours_value = hours;
        hours_counter--;

if (hours_counter <= 0)
{
  state_led1 = 8;
}
  }
    break;
    
    case 8:
    analogWrite(led3, 0);
  
    timepicker_hours = -1; // To may remove this
    timepicker_minutes = -1; // and this
    state_led1 = 0;
    break;

}

}
*/

void print_state_readEEPROM (){
if(state_readEEPROM != state_prev_readEEPROM)
{
Serial.print("                     STATE READ EEPROM = ") ; 
Serial.println(state_readEEPROM);
}
}

void print_state_writeEEPROM (){
if(state_writeEEPROM != state_prev_writeEEPROM)
{
Serial.print("                     STATE WRITE EEPROM = ") ; 
Serial.println(state_writeEEPROM);
}
}


/*
void print_state_led1 (){
if(state_led1 != state_prev_led1)
{
Serial.print("                     STATE LED 1 = ") ; 
Serial.println(state_led1);
}
}

void print_state_pump (){
if(state_pump != state_prev_pump)
{
Serial.print("\n \n \t STATE PUMP = ") ; 
Serial.println(state_pump);
}
}
*/

void test12 (){

 if(millis() >= time_now2 + period2)
{
  Tmp36();
  shtc3();
  tsl2561();
        time_now2 += period2;
 send_BT(temp_SHTC3_ID, t_scaled);    // function to write id and value to the bluetooth interface (and split value in MSB and LSB       
 send_BT(humidity_SHTC3_ID, h_scaled);    // function to write id and value to the bluetooth interface (and split value in MSB and LSB
 send_BT(TSL2561_LUX_ID,TSL2561.readVisibleLux());
 send_BT(TSL2561_FSpec_ID,TSL2561.readFSpecLuminosity());
 send_BT(TSL2561_IR_ID,TSL2561.readIRLuminosity());
 send_BT(pressure_ID, pressure_bar);  
 send_BT(ultrasonic_ID,tank_level);
 
 
}
 
 


if (Save_Global == 1)
{

  state_writeEEPROM = 2;
  
}

/*if (Save_Global == 1)
{
  state_readEEPROM = 1;

}
*/
}







const int pump = 2; // define relay pin
int state_pump = 0;
int state_prev_pump = 0;
int val_pump = 0;
unsigned long t_pump = 0; //Previous Millis()
unsigned long t_0_pump = 0; //Current Millis()




void SM_pump() {
  //Almost every state needs these lines, so I'll put it outside the State Machine
  
  state_prev_pump = state_pump;
  pump_onDuration_UL = pump_onDuration * 1000;
  pump_offDuration_UL = pump_offDuration * 60000;
  //State Machine Section
  switch (state_pump) {
    case 0: //RESET!
    //
  digitalWrite(pump, LOW);
  state_pump = 1;
    break;
    
    case 1: //WAIT
      //Do nothing.  Only the top level(main) loop can force us out of this state into state 2 "TURN ON"
    break;
  
 case 2: //TURN ON
      //Start pump, record time then proceed to ON, 
      digitalWrite(pump,HIGH);
      t_0_pump = millis();
      state_pump = 3;
    break;
       
 case 3: //ON
      //Wait for time to elapse, then proceed to TURN OFF
      t_pump = millis();
      if (t_pump - t_0_pump > pump_onDuration_UL) {state_pump = 4;}
    break;  
    
 case 4: //TURN OFF
      //, turn off relay, proceed to OFF
      
      t_0_pump = millis();
      digitalWrite(pump,LOW);
      state_pump = 5;
    break; 
    
 case 5: //OFF
      t_pump = millis();
      if (t_pump - t_0_pump > pump_offDuration_UL) {state_pump = 6;}
    
      //if (beep_count_led1 >= beep_number_led1) {state_led1 = 0;}
    break;
 case 6: //RECORD CURRENT TIME
      t_0_pump = millis();
      state_pump = 7;
	 break; 
 case 7: //WAIT THEN FINISH
      t_pump = millis();
      if (t_pump - t_0_pump > 200) {state_pump = 0;}
	 break;   
  	}
  }